# 类型转换

## Javascript type conversions

| 值 | 转换为字符串 | 转换为数值 | 转换为布尔值
| ---- | ---- | ---- | ----
| undefined | "undefined" | NaN | false
| null | "null" | 0 | false
| true | "true" | 1 | -
| false | "false" | 0 | -
| ""(空字符串) | - | 0 | false
| "1.2"(非空，数值) | - | 1.2 | true
| "one"(非空，非数值) | - | NaN | true
| 0 | "0" | - | false
| -0 | "0" | - | false
| 1 (有限，非零) | "1" | - | true
| Infinity | "Infinity" | - | true
| -Infinity | "-Infinity" | - | true
| NaN | "NaN" | - | false
| `{}`(任何对象) | 参见3.9.3 | 参见3.9.3 | true
| `[]`(空数组) | "" | 0 | true
| `[9]`(一个数值元素) | "9" | 9 | true
| `['a']`(任何其他数组) | 使用join方法 (存疑：数组的toString是调用join方法？) | NaN | true
| Function(){} | 参见3.9.3 | NaN | true

### 操作副转换特例

`+`加号操作符执行数值加法和字符串拼接，如果一个操作数是对象，则使用无偏好算法将对象转换为原始值。如果两个操作数都是原始值，下检查各自的类型，如果其中一个参数为字符串，则另一个原始值也转换为字符串进行字符串拼接操作，否则都转换为数值并相加

```js
// 陷阱 ES6引入了块级作用域，这里{}被当作了块被舍弃了
{} + 1 // => 1
{} + '1' // => 1
{} - 1 // => -1
{} - '1' // => -1

// throw error
{} / 1
{} * 1
```

`==`，`!=`允许以类型转换的宽松方式执行相等和不相等判断，如果一个操作数是对象，另一个是原始值，则会使用无偏好算法将对象转换为原始值，然后比较两个原始值。

`<`,`>`,`>=`,`<=`，如果操作数其中有一个是对象，则使用偏数值算法将对象转换为原始值，需要注意的是，这个偏数值算法返回的原始值不会再被转换为数值。

```js
['干'] >= '干' // => true
'干' >= {a : '干'} // => true
```

## 对象到原始值转换算法

- 偏字符串算法首先尝试`toString()`方法。如果这个方法有定义且返回原始值，则使用该值（即使不是字符串）。如果`toString()`方法不存在或者返回对象，则尝试`valueOf()`方法。如果这个方法存在且返回原始值，则使用该值。否则，转换失败，报TypeError。
- 偏数值算法与偏字符串算法类似，先尝试`valueOf()`方法，再尝试`toString()`方法。
- 无偏好算法取决于被转换对象的类。如果是Date对象，则使用偏字符串算法，如果是其他类型的对象，则使用偏数值算法。

补充说明

```js
Number([]) // => 0
Number([99]) // => 99
```

Array类继承了默认的`valueOf()`方法，不会返回原始值，因此最终会调用`toString()`方法，空数组转换为空字符串，而空字符串转换为数值0，只有一个元素的数组转换为该元素对应的空字符串。如果数组只包含一个数值，则该数值先转换为字符串，再转换为数值。
